# 模块管理器

模块管理器是整个系统的核心处理对象，它负责整个系统启动以及运行时的逻辑处理，包括配置信息的加载，模块的动态导入和模块控制等逻辑。

具体来说，为了实现模块之间的“高内聚，低耦合”，我们抽象出一层模块管理单元 `ModuleManageCell` 针对模块进行单独管理。模块管理器主要有 3 个部分组成。

-   模块加载器 `ModuleLoader`: 负责配置文件和模块加载
-   模块管理单元 `ModuleCells`: 所有模块的管理单元
-   根管理单元 `RootCell`: 模块依赖树的根节点对应的管理单元

<!-- 虽然在之前的系统设计上，我们称系统中的每一个功能组件都是一个模块，
但实际上在具体的代码实现，每个模块的内部实现不同，导致其具体实现上有一定的差异，
使得我们需要为每个类都涉及一套代码实现，并且还需要手动地加载和连接各个模块。

因此，为了简化这部分的代码开发工作量，让系统本身自动化地完成模块加载和连接，
我们提出了模块化的思想。

> 注意：本系统在代码实现层面不再刻意区分 `interface` 和 `module`，
> 而是在具体的功能性质上有所差异。
> 比如 `interface` 主要负责对外交互，`module` 主要负责内部实现。 -->

## 模块加载器

模块加载器

## 概念

<!-- 这里模块化思想其实与 Linux 系统中的文件系统如出一辙，
在 Linux 系统中，所有的硬件设备、文件内容和文件夹都属于文件，
共用一套统一的 IO 控制接口。 -->

<!-- 在我们这套系统中也是如此，任何一个具体模块都继承与一个统一的模块接口，
它们共用一套统一的启动、运行和管理接口。
此外，模块之间也能互相嵌套（不允许发生循环依赖），父模块会自动加载子模块。 -->

模块化的概念是指在本系统中的所有功能实现都属于模块，
都继承于 `BasicModule` 对象。
同时，模块具有嵌套性，
也就是说一个模块会包含多个子模块，
通过父子模块的关联系，其在系统内部形成一条紧密的依赖树，
在实际开发过程中，开发者就不需要手动创建各个模块。

除了大语言模型、文本转语音这些实际提供功能的传统模块之外，
将这些功能组合起来的对象也属于模块，
所以，实质上来说，
数字人系统其内核就是一个包含许多子模块的嵌套的大型模块。

在模块化的框架，其最重要的是 模块化管理器 (`ModuleManager`)。
管理器会自动从配置文件中加载模块信息 (`ModuleInfo`)，
然后将其封装成一些模块管理单元 (`ModuleManageCell`)，
此后在运行时动态地导入这些模块，并注入模块相关的依赖。

![img](./img/modular.svg)

### IoC 与 DI

在先前的模块化架构设计中，模块实现为了获取到全局的信息，
需要拥有模块管理器的单例实现，
这样也会导致出现一条额外的依赖关系，造成循环依赖。
此后，我们参考 Spring 框架的**控制反转**和**依赖注入**，
砍掉了这条多余的依赖。

-   **控制反转**：在此前，用户的对模块的启停操控是对模块本身进行控制。
    但在目前系统架构中，所有对模块的操作都是通过模块管理器，
    也就是说控制权发生了反转。
-   **依赖注入**：模块实现获取全局信息，不再是拥有模块管理器来获取，
    而是管理器在加载模块时，通过我 set 函数将模块需要的依赖（包括模块名称、实现类型和子模块等）
    注入给该模块。

## 生命周期

本系统的生命周期包含两个主要阶段，分别是**加载阶段**和**运行阶段**。
前者主要是在系统初始阶段对模块进行加载，在运行阶段的时候，也可以对模块进行重新加载。
后者则主要是系统从开始到结束这一段时期。

### 1. 加载阶段

`ModuleManager` 统一对模块进行加载，
这是本架构中最重要的部分，
它省去大部分导入模块，设置配置信息和管理子模块的工作，
只需要通过配置文件和少量的代码就可以拉起整个庞大系统。

加载阶段分为自动加载和手动加载。
系统会在初始阶段自动地加载所有配置的模块信息，并验证模块是否正确。
手动加载则是允许管理员在后期手动对某些模块进行切换。

> **注意:** 由于加载阶段是由管理器自动运行，
> 管理器不会使用构造函数传递值进行初始化，因此请保证每个模块对象都存在无参构造，或者每个参数都存在默认是。
>
> 由于模块构造之后，并不代表真正运行，所以切记不要在构造函数 `__init__` 编写过多需要处理运行的逻辑，
> 这些逻辑应该通过重写在运行阶段的**钩子函数**实现 。

#### a. 自动加载

自动加载阶段分为以下 3 个步骤。

> **注意:** 自动加载需要在程序启动时手动调用 `manager.load_modules()` 函数。
> 如果程序在类加载阶段进行自动加载，则会出现**循环依赖**的问题，
> 因此只能在运行时刻手动调用。

##### 加载模块信息

管理器会读取`modules.json`文件，并将其解析成 `ModuleInfo`对象，
最后在为每个模块创建对应的管理单元。
配置文件的格式如下所示，基本内容与上述的属性值相同，

> **注意:** 在`ModuleInfo`属性名使用下划线命名法，而`modules.json`中使用小驼峰命名法。

```typescript
interface Config {
    name: ModuleInfo;
}

interface ModuleInfo {
    alias: string;
    // 默认加载的实现类型，系统启动时会加载该实现类型
    default?: string;
    kinds?: string[];
    modules?: string[];
    path?: string;
    notNull?: boolean;
}
```

`ModuleInfo` 中的属性可以根据可配置性可以分为以下 3 类。
无论是哪种类型，其都作为模块属性，并且可以被访问。

1. 必须项：属性必须配置
2. 可选项：如果属性没有配置，系统也会赋予默认值
3. 生成项：属性无需配置，系统会在根据其他属性进行计算生成得到

为了方便配置，本系统也存在以下配置语法糖。

-   当`kind`没有被配置或为`basic`，且`kinds`没有被配置或为空数组。系统会设置默认配置为`basic`，且被实现类型包含。
-   当配置`notNull`为`false`时，会自动向`kinds`中添加`null`

> **注意:** 目前并没有对`kinds`中的`null`进行冗余检查，所以设置 `not_null` 为 `false` 后，
> 请勿再在 `kinds` 中添加 `kind`

##### 验证模块依赖

验证模块分为两部分内容，分别是模块本身的验证，然后是其实现类型的验证。

本系统重模块之间的依赖关系是树状的，
也就是不允许出现环，且每个模块只能被一个父模块所依赖。验证阶段首先会验证依赖的模块是否存在，
然后再通过 BFS 算法验证是否出现循环依赖和交叉依赖，
最后验证模块的具体实现是否存在。
除此之外，在本阶段还能计算出每个子模块的嵌套深度。

> TODO: 交叉验证仍未实现...

验证模块实现类型时，首先会验证当前选择的实现类型是否包含在可支持的列表 (`kinds`) 中，
然后通过一下动态导入验证这些实例对象是否存在。
值得注意的是，此处仅是导入，并不会创建实例对象。

### 2. 运行阶段

1. **未运行** `Stopped`
2. **启动中** `Starting`
    1. “启动子模块”前钩子函数
    2. 启动子模块: 逐一启动子模块
    3. 更新配置信息: 从配置文件中重新读取配置文件
    4. 自定义启动逻辑
    5. 模块自检: 通过调用自定义的检测逻辑，保证模块时可运行的
3. **运行中** `Started`
4. **停止中** `Stopping`
    1. 自定义停止逻辑
    2. 等待线程停止(可选): 等待所有线程运行完毕，以优雅停机
    3. 停止子模块: 逐一停止已经运行的模块
    4. “停止子模块”后钩子函数
5. **未运行** `Stopped`

值得注意的是，在启动时，父模块需要等子模块都启动完成后，
才会启动付模块的内部逻辑。
而在停止时，父模块则会首先停止模块的内部逻辑，
然后再停止子模块逻辑。
此处区别在开发时需要注意甄别。

#### b. 级联启动

本系统存在父子模块依赖的关系，因此在管理器启动模块时，
也会级联启动其父模块或子模块。
对于控制模块启动的函数中，
系统提供了两个参数，`with_sub` 与 `with_sup`。
前者会级联启动该模块的所有子模块，
后者则会级联启动该模块的父模块。
值得注意的是，级联启动具有方向性，
也就是当子模块启动父模块，只会继续启动父模块的父模块，
而不会启动父模块的子模块。当然，子模块同理。

管理员在控制模块时，既会级联启动其父模块，也会级联启动其子模块，
其顺序为 子模块 -> 本身 -> 父模块。
